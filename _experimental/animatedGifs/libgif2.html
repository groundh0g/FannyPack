<html>
	<body>
		<!-- <img id="foo" src="hakuku.gif" rel:animated_src="hakuku.gif" width="50" height="50" rel:auto_play="1" /> -->
		<input id="uploadProject" type="file" name="submitfile" onchange="return TestParseGIF(this.files);" />
		
		<script type="text/javascript" src="../../assets/js/jquery-1.8.3.js"></script>
		<script type="text/javascript" src="libgif.js"></script>
		<script type="text/javascript">

		var GifParser = function(options, callback) {
			var self = this;
			
			this.options = options;
			this.callback = callback;
			
			this.source = null;
			this.frame = null;
			this.frames = [];

			this.transparency = null;
			this.delay = null;
			this.disposalMethod = null;
			this.disposalRestoreFromIdx = 0;
			this.lastDisposalMethod = null;
			this.lastImg = null;

			//this.playing = true;
			//this.forward = true;

			this.ctx_scaled = false;
			
			this.canvas = document.createElement('canvas');
			this.canvas.width = "50px";
			this.canvas.height = "50px";
			this.ctx = this.canvas.getContext('2d');
			this.tmpCanvas = document.createElement('canvas');

			this.clear = function () {
				self.transparency = null;
				self.delay = null;
				self.lastDisposalMethod = self.disposalMethod;
				self.disposalMethod = null;
				self.frame = null;
			};
			
			this.setSizes = function(w, h) {
				self.canvas.width = w * self.get_canvas_scale();
				self.canvas.height = h * self.get_canvas_scale();

				self.tmpCanvas.width = w;
				self.tmpCanvas.height = h;
				self.tmpCanvas.style.width = w + 'px';
				self.tmpCanvas.style.height = h + 'px';
				self.tmpCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
			};

			this.get_canvas_scale = function() { return 1; }
			
			this.doNothing = function() { };
			
			this.pushFrame = function () {
				if (!self.frame) return;
				self.frames.push({
					data: self.frame.getImageData(0, 0, self.hdr.width, self.hdr.height),
					delay: self.delay
				});
			};
			
			this.handler = {
				hdr: function (_hdr) {
					self.hdr = _hdr;
					self.setSizes(self.hdr.width, self.hdr.height)
				},
				gce: function (gce) {
					self.pushFrame();
					self.clear();
					self.transparency = gce.transparencyGiven ? gce.transparencyIndex : null;
					self.delay = gce.delayTime;
					self.disposalMethod = gce.disposalMethod;
				},
				com: self.doNothing,
				app: {
					NETSCAPE: self.doNothing
				},
				img: function (img) {
					if (!self.frame) self.frame = self.tmpCanvas.getContext('2d');

					var currIdx = self.frames.length;

					//ct = color table, gct = global color table
					var ct = img.lctFlag ? img.lct : self.hdr.gct; // TODO: What if neither exists?

					/*
					Disposal method indicates the way in which the graphic is to
					be treated after being displayed.

					Values :    0 - No disposal specified. The decoder is
									not required to take any action.
								1 - Do not dispose. The graphic is to be left
									in place.
								2 - Restore to background color. The area used by the
									graphic must be restored to the background color.
								3 - Restore to previous. The decoder is required to
									restore the area overwritten by the graphic with
									what was there prior to rendering the graphic.

									Importantly, "previous" means the frame state
									after the last disposal of method 0, 1, or 2.
					*/
					if (currIdx > 0) {
						if (self.lastDisposalMethod === 3) {
							// Restore to previous
							self.frame.putImageData(self.frames[self.disposalRestoreFromIdx].data, 0, 0);
						} else {
							self.disposalRestoreFromIdx = currIdx - 1;
						}

						if (self.lastDisposalMethod === 2) {
							// Restore to background color
							// Browser implementations historically restore to transparent; we do the same.
							// http://www.wizards-toolkit.org/discourse-server/viewtopic.php?f=1&t=21172#p86079
							self.frame.clearRect(self.lastImg.leftPos, self.lastImg.topPos, self.lastImg.width, self.lastImg.height);
						}
					}
					// else, Undefined/Do not dispose.
					// frame contains final pixel data from the last frame; do nothing

					//Get existing pixels for img region after applying disposal method
					var imgData = self.frame.getImageData(img.leftPos, img.topPos, img.width, img.height);

					//apply color table colors
					var cdd = imgData.data;
					img.pixels.forEach(function (pixel, i) {
						// imgData.data === [R,G,B,A,R,G,B,A,...]
						if (pixel !== self.transparency) {
							cdd[i * 4 + 0] = ct[pixel][0];
							cdd[i * 4 + 1] = ct[pixel][1];
							cdd[i * 4 + 2] = ct[pixel][2];
							cdd[i * 4 + 3] = 255; // Opaque.
						}
					});
					imgData.data = cdd;

					self.frame.putImageData(imgData, img.leftPos, img.topPos);

					if (!self.ctx_scaled) {
						self.ctx.scale(self.get_canvas_scale(),self.get_canvas_scale());
						self.ctx_scaled = true;
					}

					// We could use the on-page canvas directly, except that we draw a progress
					// bar for each image chunk (not just the final image).
					self.ctx.drawImage(self.tmpCanvas, 0, 0);

					self.lastImg = img;
				},
				eof: function (block) {
					self.pushFrame();
					//console.log(new Date());
				},
				callback: function() {}
			};

			this.loadFromURL = function(url, callback) {
				var request = new XMLHttpRequest();
				request.overrideMimeType('text/plain; charset=x-user-defined');
				request.filename = url;
				request.filetype = "image/gif";
				request.onload = function(e) {
					var stream = new Stream(request.responseText);
					stream.sourcePath = this.filename;
					stream.sourceType = this.filetype;
					stream.loadMethod = "loadFromURL";
					self.loadFromStream(stream, callback);
				};
				request.onerror = function() { 
					throw "ERROR: Unable to retrieve image at '" + this.filename + "'.";
				};
				request.open('GET', gif.getAttribute('rel:animated_src') || gif.src, true);
				request.send();
			};
			
			this.loadFromFile = function(files, callback) {
				var file = null;
				
				if(files && files.length && files[0].name) {
					file = files[0];
				} else if(files && files.name) {
					file = files;
				} else {
					throw "ERROR: Parameter 'files' must be a valid file object or an array of file obects(from <INPUT type='file' ... />).";
				}
				
				var reader = new FileReader();
				reader.filename = file.name;
				reader.filetype = file.type;
				reader.onload = function(e) {
					var stream = new Stream(e.target.result);
					stream.sourcePath = this.filename;
					stream.sourceType = this.filetype;
					stream.loadMethod = "loadFromFile";
					self.loadFromStream(stream, callback);
				};
				reader.readAsBinaryString(file);
			};

			this.loadFromStream = function(stream, callback) {
				parseGIF(stream, self.handler);
				(callback || self.callback || doNothing)();
				return false;
			};
		
		};

		var parser = null;
		var TestParseGIF = function(files) {
			/*
			if(files && files.length) {
				var file = files[0];
				var reader = new FileReader();
				reader.filename = file.name;
				reader.filetype = file.type;
				reader.onload = function(e) { 
					var stream2 = new Stream(e.target.result);
				};
				console.log(new Date());
				reader.readAsBinaryString(file);
			}
			*/
			parser = new GifParser({}, foo );
			parser.loadFromFile(files);
			return false;
		};
		
		var foo = function() {
			alert("done!"); 
			console.log(parser);
		};
		</script>
	</body>
</html>