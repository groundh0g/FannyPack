<html>
	<body>
		<!-- <img id="foo" src="hakuku.gif" rel:animated_src="hakuku.gif" width="50" height="50" rel:auto_play="1" /> -->
		<input id="uploadProject" type="file" name="submitfile" onchange="return TestParseGIF(this.files);" />
		
		<script type="text/javascript" src="../../jquery-1.8.3.js"></script>
		<script type="text/javascript" src="libgif.js"></script>
		<script type="text/javascript">

		
	var get_canvas_scale = function() {
		var scale;
		if (options.max_width && hdr) {
			scale = options.max_width / hdr.width;
		}
		else {
			scale = 1;
		}
		return scale;
	}

	var canvas, ctx, toolbar, tmpCanvas;
		
		canvas = document.createElement('canvas');
		ctx = canvas.getContext('2d');

		tmpCanvas = document.createElement('canvas');

		canvas.width = "50px";
		canvas.height = "50px";


		
	var options = {
		//viewport position
		vp_l: 0,
		vp_t: 0,
		vp_w: null,
		vp_h: null,
		//canvas sizes
		c_w: null,
		c_h: null
	};
	//for (var i in opts ) { options[i] = opts[i] }
	if (options.vp_w && options.vp_h) options.is_vp = true;

	var stream;
	var hdr;

	var loadError = null;
	var loading = false;

	var transparency = null;
	var delay = null;
	var disposalMethod = null;
	var disposalRestoreFromIdx = 0;
	var lastDisposalMethod = null;
	var frame = null;
	var lastImg = null;

	var playing = true;
	var forward = true;

	var ctx_scaled = false;

	var frames = [];

	//var gif = options.gif;
	//if (typeof options.auto_play == 'undefined') 
	//	options.auto_play = (!gif.getAttribute('rel:auto_play') || gif.getAttribute('rel:auto_play') == '1');
	//
	var clear = function () {
		transparency = null;
		delay = null;
		lastDisposalMethod = disposalMethod;
		disposalMethod = null;
		frame = null;
	};

	// XXX: There's probably a better way to handle catching exceptions when
	// callbacks are involved.
	var doParse = function () {
		try {
			parseGIF(stream, handler);
		}
		catch (err) {
			doLoadError('parse');
		}
	};

	var doText = function (text) {
		toolbar.innerHTML = text; // innerText? Escaping? Whatever.
		toolbar.style.visibility = 'visible';
	};

	var setSizes = function(w, h) {
		canvas.width = w * get_canvas_scale();
		canvas.height = h * get_canvas_scale();
		//toolbar.style.minWidth = ( w * get_canvas_scale() ) + 'px';

		tmpCanvas.width = w;
		tmpCanvas.height = h;
		tmpCanvas.style.width = w + 'px';
		tmpCanvas.style.height = h + 'px';
		tmpCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
	}

	var doShowProgress = function (pos, length, draw) {
		if (draw) {
			var height = 25;
			var left, mid, top, width;
			if (options.is_vp) {
				if (!ctx_scaled) {
					top = (options.vp_t + options.vp_h - height);
					height = height;
					left = options.vp_l;
					mid = left + (pos / length) * options.vp_w;
					width = canvas.width;
				} else {
					top = (options.vp_t + options.vp_h - height) / get_canvas_scale();
					height = height / get_canvas_scale();
					left = (options.vp_l / get_canvas_scale() );
					mid = left + (pos / length) * (options.vp_w / get_canvas_scale());
					width = canvas.width / get_canvas_scale();
				}
				//some debugging, draw rect around viewport
				if (false) {
					if (!ctx_scaled) {
						var l = options.vp_l, t = options.vp_t;
						var w = options.vp_w, h = options.vp_h;
					} else {
						var l = options.vp_l/get_canvas_scale(), t = options.vp_t/get_canvas_scale();
						var w = options.vp_w/get_canvas_scale(), h = options.vp_h/get_canvas_scale();
					}
					ctx.rect(l,t,w,h);
					ctx.stroke();
				}
			}
			else {
				top = canvas.height - height;
				mid = (pos / length) * canvas.width;
				width = canvas.width;
			}
			// XXX Figure out alpha fillRect.
			//ctx.fillStyle = 'salmon';
			ctx.fillStyle = 'rgba(255,255,255,0.4)';
			ctx.fillRect(mid, top, width - mid, height);

			//ctx.fillStyle = 'teal';
			ctx.fillStyle = 'rgba(255,0,22,.8)';
			ctx.fillRect(0, top, mid, height);
		}
	};

	var doLoadError = function (originOfError) {
		var drawError = function () {
			ctx.fillStyle = 'black';
			ctx.fillRect(0, 0, options.c_w ? options.c_w : hdr.width, options.c_h ? options.c_h : hdr.height);
			ctx.strokeStyle = 'red';
			ctx.lineWidth = 3;
			ctx.moveTo(0, 0);
			ctx.lineTo(options.c_w ? options.c_w : hdr.width, options.c_h ? options.c_h : hdr.height);
			ctx.moveTo(0, options.c_h ? options.c_h : hdr.height);
			ctx.lineTo(options.c_w ? options.c_w : hdr.width, 0);
			ctx.stroke();
		};

		loadError = originOfError;
		hdr = {
			width: gif.width,
			height: gif.height
		}; // Fake header.
		frames = [];
		drawError();
	};

	var doHdr = function (_hdr) {
		hdr = _hdr;
		setSizes(hdr.width, hdr.height)
	};

	var doGCE = function (gce) {
		pushFrame();
		clear();
		transparency = gce.transparencyGiven ? gce.transparencyIndex : null;
		delay = gce.delayTime;
		disposalMethod = gce.disposalMethod;
		// We don't have much to do with the rest of GCE.
	};

	var pushFrame = function () {
		if (!frame) return;
		frames.push({
			data: frame.getImageData(0, 0, hdr.width, hdr.height),
			delay: delay
		});
	};

	var doImg = function (img) {
		if (!frame) frame = tmpCanvas.getContext('2d');

		var currIdx = frames.length;

		//ct = color table, gct = global color table
		var ct = img.lctFlag ? img.lct : hdr.gct; // TODO: What if neither exists?

		/*
		Disposal method indicates the way in which the graphic is to
		be treated after being displayed.

		Values :    0 - No disposal specified. The decoder is
						not required to take any action.
					1 - Do not dispose. The graphic is to be left
						in place.
					2 - Restore to background color. The area used by the
						graphic must be restored to the background color.
					3 - Restore to previous. The decoder is required to
						restore the area overwritten by the graphic with
						what was there prior to rendering the graphic.

						Importantly, "previous" means the frame state
						after the last disposal of method 0, 1, or 2.
		*/
		if (currIdx > 0) {
			if (lastDisposalMethod === 3) {
				// Restore to previous
				frame.putImageData(frames[disposalRestoreFromIdx].data, 0, 0);
			} else {
				disposalRestoreFromIdx = currIdx - 1;
			}

			if (lastDisposalMethod === 2) {
				// Restore to background color
				// Browser implementations historically restore to transparent; we do the same.
				// http://www.wizards-toolkit.org/discourse-server/viewtopic.php?f=1&t=21172#p86079
				frame.clearRect(lastImg.leftPos, lastImg.topPos, lastImg.width, lastImg.height);
			}
		}
		// else, Undefined/Do not dispose.
		// frame contains final pixel data from the last frame; do nothing

		//Get existing pixels for img region after applying disposal method
		var imgData = frame.getImageData(img.leftPos, img.topPos, img.width, img.height);

		//apply color table colors
		var cdd = imgData.data;
		img.pixels.forEach(function (pixel, i) {
			// imgData.data === [R,G,B,A,R,G,B,A,...]
			if (pixel !== transparency) {
				cdd[i * 4 + 0] = ct[pixel][0];
				cdd[i * 4 + 1] = ct[pixel][1];
				cdd[i * 4 + 2] = ct[pixel][2];
				cdd[i * 4 + 3] = 255; // Opaque.
			}
		});
		imgData.data = cdd;

		frame.putImageData(imgData, img.leftPos, img.topPos);

		if (!ctx_scaled) {
			ctx.scale(get_canvas_scale(),get_canvas_scale());
			ctx_scaled = true;
		}

		// We could use the on-page canvas directly, except that we draw a progress
		// bar for each image chunk (not just the final image).
		ctx.drawImage(tmpCanvas, 0, 0);

		lastImg = img;
	};
	
	var doNothing = function () {};
	
	var handler = {
		hdr: doHdr,
		gce: doGCE,
		com: doNothing,
		// I guess that's all for now.
		app: {
			// TODO: Is there much point in actually supporting iterations?
			NETSCAPE: doNothing
		},
		img: doImg,
		eof: function (block) {
			//toolbar.style.display = '';
			pushFrame();
			//doDecodeProgress(false);
			//if ( ! (options.c_w && options.c_h) ) {
			//	canvas.width = hdr.width * get_canvas_scale();
			//	canvas.height = hdr.height * get_canvas_scale();
			//}
			//player.init();
			//loading = false;
			//if (load_callback) {
			//	load_callback(gif);
			//}
			console.log(new Date());
		}
	};
	
			var TestParseGIF = function(files) {
				if(files && files.length) {
					var file = files[0];
					var reader = new FileReader();
					reader.filename = file.name;
					reader.filetype = file.type;
					reader.onload = function(e) { 
						var stream2 = new Stream(e.target.result);
						parseGIF(stream2, handler);
						return false;
					};
					console.log(new Date());
					reader.readAsBinaryString(file);
				}
				return false;
			};
		</script>
	</body>
</html>